<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Apache Spark: A Tutorial</title>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['$$$','$$$']]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<h1>Apache Spark: A Tutorial</h1>

<div><h2>Introduction</h2>

<p>This workshop demonstrates how to write and run <a href="http://spark.apache.org">Apache Spark</a> <em>Big Data</em> applications.</p>

<p><a href="http://spark.apache.org">Apache Spark</a> is a distributed computing system written in Scala and developed initially as a UC Berkeley research project for distributed data programming. It has grown in capabilities and it recently became a top-level <a href="http://spark.apache.org">Apache project</a>.</p>

<p>We'll run our exercises "locally" on our laptops, which is very convenient for learning, development, and "unit" testing. However, there are several ways to run Spark clusters. There is even a <em>Spark Shell</em>, a customized version of the Scala REPL (read, eval, print loop shell), for interactive use.</p>

</div><div><h2>Why Spark?</h2>

<p>By 2013, it became increasingly clear that a successor was needed for the venerable <a href="http://wiki.apache.org/hadoop/MapReduce">Hadoop MapReduce</a> compute engine. MapReduce applications are difficult to write, but more importantly, MapReduce has significant performance limitations and it can't support event-streaming ("real-time") scenarios.</p>

<p>Spark was seen as the best, general-purpose alternative, so <a href="http://databricks.com/blog/2013/10/28/databricks-and-cloudera-partner-to-support-spark.html">Cloudera led the way</a> in embracing Spark as a replacement for MapReduce.</p>

<p>Spark is now officially supported in <a href="http://blog.cloudera.com/blog/2014/04/how-to-run-a-simple-apache-spark-app-in-cdh-5/">Cloudera CDH5</a> and <a href="http://blog.cloudera.com/blog/2014/04/how-to-run-a-simple-apache-spark-app-in-cdh-5/">MapR's distribution</a>. Hortonworks has not yet announced whether or not they will support Spark natively, but <a href="http://spark.apache.org/docs/1.0.0/cluster-overview.html">this page</a> in the Spark documentation discusses general techniques for running Spark with various versions of Hadoop, as well as other deployment scenarios.</p>

</div><div><h2>Spark Clusters</h2>

<p>Let's briefly discuss the anatomy of a Spark standalone cluster, adapting <a href="http://spark.apache.org/docs/1.0.0/cluster-overview.html">this discussion (and diagram) from the Spark documentation</a>. Consider the following diagram:</p>

<p><img src="http://spark.apache.org/docs/1.0.0/img/cluster-overview.png" alt="Spark Cluster" /></p>

<p>Each program we'll write is a <em>Driver Program</em>. It uses a <em>SparkContext</em> to communicate with the <em>Cluster Manager</em>, either Spark's own manager or the corresponding management services provided by <a href="http://mesos.apache.org/">Mesos</a> or <a href="http://hadoop.apache.org/docs/r2.3.0/hadoop-yarn/hadoop-yarn-site/YARN.html">Hadoop's YARN</a>. The <em>Cluster Manager</em> allocates resources. An <em>Executor</em> JVM process is created on each worker node per client application. It manages local resources, such as the cache (see below) and it runs tasks, which are provided by your program in the form of Java jar files or Python scripts.</p>

<p>Because each application has its own executor process per node, applications can't share data through the <em>Spark Context</em>. External storage has to be used (e.g., the file system, a database, a message queue, etc.)</p>

<p>When possible, run the driver locally on the cluster to reduce network IO as it creates and manages tasks.</p>

</div><div><h2>Spark Deployment Options</h2>

<p>Spark currently supports <a href="http://spark.apache.org/docs/1.0.0/cluster-overview.html">three cluster managers</a>:</p>

<ul>
<li><a href="http://spark.apache.org/docs/1.0.0/spark-standalone.html">Standalone</a> – A simple manager bundled with Spark for manual deployment and management of a cluster. It has some high-availability support, such as Zookeeper-based leader election of redundant master processes.</li>
<li><a href="http://spark.apache.org/docs/1.0.0/running-on-mesos.html">Apache Mesos</a> – <a href="http://mesos.apache.org/">Mesos</a> is a general-purpose cluster management system that can also run <a href="http://hadoop.apache.org">Hadoop</a> and other services.</li>
<li><a href="http://spark.apache.org/docs/1.0.0/running-on-yarn.html">Hadoop YARN</a> – <a href="http://hadoop.apache.org/docs/r2.3.0/hadoop-yarn/hadoop-yarn-site/YARN.html">YARN</a> is the <a href="http://hadoop.apache.org">Hadoop</a> v2 resource manager.</li>
</ul>


<p>Note that you can run Spark on a Hadoop cluster using any of these three approaches, but only YARN deployments truly integrate resource management between Spark and Hadoop jobs. Standalone and Mesos deployments within a Hadoop cluster require that you statically configure some resources for Spark and some for Hadoop, because Spark and Hadoop are unaware of each other in these configurations.</p>

<p>For information on using YARN, see <a href="http://spark.apache.org/docs/1.0.0/running-on-yarn.html">here</a>.</p>

<p>For information on using Mesos, see <a href="http://spark.apache.org/docs/1.0.0/running-on-mesos.html">here</a> and <a href="http://mesosphere.io/learn/run-spark-on-mesos/">here</a>.</p>

<p>Spark also includes <a href="http://spark.apache.org/docs/1.0.0/ec2-scripts.html">EC2 launch scripts</a> for running clusters on Amazon EC2.</p>

</div><div><h2>Resilient, Distributed Datasets</h2>

<p>The data caching is one of the key reasons that Spark's performance is considerably better than the performance of MapReduce. Spark stores the data for the job in <em>Resilient, Distributed Datasets</em> (RDDs), where a logical data set is virtualized over the cluster.</p>

<p>The user can specify that data in an RDD should be cached in memory for subsequent reuse. In contrast, MapReduce has no such mechanism, so a complex job requiring a sequence of MapReduce jobs will be penalized by a complete flush to disk of intermediate data, followed by a subsequent reloading into memory by the next job.</p>

<p>RDDs support common data operations, such as <em>map</em>, <em>flatmap</em>, <em>filter</em>, <em>fold/reduce</em>, and <em>groupby</em>. RDDs are resilient in the sense that if a "partition" of data is lost on one node, it can be reconstructed from the original source without having to start the whole job over again.</p>

<p>The architecture of RDDs is described in the research paper <a href="https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final138.pdf">Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</a>.</p>

</div><div><h2>The Spark Version</h2>

<p>This workshop uses Spark 1.0.0.</p>

<p>The following documentation links provide more information about Spark:</p>

<ul>
<li><a href="http://spark.apache.org/docs/1.0.0/">Documentation</a>.</li>
<li><a href="http://spark.apache.org/docs/1.0.0/api/core/index.html#org.apache.spark.package">API</a>.</li>
</ul>


<p>The <a href="http://spark.apache.org/docs/1.0.0/">Documentation</a> includes a getting-started guide, overviews, and the <em>Scaladocs</em> reference pages.</p>

</div><div><h2>Building and Testing</h2>

<p>If you're using the <a href="http://typesafe.com/activator">Activator UI</a>, search for <code>activator-spark</code> and install it in the UI. The code is built automatically.</p>

<p>If you grabbed this workshop from <a href="https://github.com/deanwampler/activator-spark">Github</a>, you'll need to install <code>sbt</code> and use a command line to build and run the applications. In that case, see the <a href="http://www.scala-sbt.org/">sbt website</a> for instructions on installing <code>sbt</code>.</p>

<p>If you're using the Activator UI, first run the automated tests with <a class="shortcut" href="#test">test</a>.</p>

<p>If you are using <code>sbt</code> from the command line, start <code>sbt</code>, then type <code>test</code>.</p>

<p>Either way, the code is compiled and the tests are executed. They should pass without error. Note that tests are provided for all the exercises, except the last <em>Spark Streaming</em> exercise (for various reasons...).</p>

</div><div><h2>Running the Exercises</h2>

<p>Next, let's try running one of the exercises.</p>

<p>In Activator, use the <a class="shortcut" href="#run">run</a> panel, select one of the bullet items under "Main Class", for example <code>WordCount2</code>, and click the "Start" button. The "Logs" panel shows some information. Note the <code>output</code> directories listed in the output. Use a file browser to find those directories to view the output written in those locations.</p>

<p>In <code>sbt</code>, enter <code>run</code>. It will present the same list of main classes. Enter one of the numbers to select the executable you want to run. Enter the number in the <code>[...]</code> brackets corresponding to  <strong>WordCount2</strong> to verify that everything works.</p>

<p>Note that the exercises with package names that contain <code>solns</code> are solutions to exercises. The <code>other</code> package has alternative implementations for your consideration.</p>

</div><div><h2>The Exercises</h2>

<p>Here is a list of the exercises. In subsequent sections, we'll dive into the details for each one. Note that each name ends with a number, indicating the order in which we'll discuss and try them:</p>

<ul>
<li><strong>Intro1:</strong> Actually, this <em>isn't</em> listed by the <code>run</code> command, because it is a script we'll use with the interactive <em>Spark Shell</em>.</li>
<li><strong>WordCount2:</strong> The <em>Word Count</em> algorithm: Read a corpus of documents, tokenize it into words, and count the occurrences of all the words. A classic, simple algorithm used to learn many Big Data APIs. By default, it uses a file containing the King James Version (KJV) of the Bible. (The <code>data</code> directory has a <a href="data/README.html">README</a> that discusses the sources of the data files.)</li>
<li><strong>WordCount3:</strong> An alternative implementation of <em>Word Count</em> that uses a slightly different approach and also uses a library to handle input command-line arguments, demonstrating some idiomatic (but fairly advanced) Scala code.</li>
<li><strong>Matrix4:</strong> Demonstrates Spark's Matrix API, useful for many machine learning algorithms.</li>
<li><strong>Crawl5a:</strong> Simulates a web crawler that builds an index of documents to words, the first step for computing the <em>inverse index</em> used by search engines. The documents "crawled" are sample emails from the Enron email dataset, each of which has been classified already as SPAM or HAM.</li>
<li><strong>InvertedIndex5b:</strong> Using the crawl data, compute the index of words to documents (emails).</li>
<li><strong>NGrams6:</strong> Find all N-word ("NGram") occurrences matching a pattern. In this case, the default is the 4-word phrases in the King James Version of the Bible of the form <code>% love % %</code>, where the <code>%</code> are wild cards. In other words, all 4-grams are found with <code>love</code> as the second word. The <code>%</code> are conveniences; the NGram Phrase can also be a regular expression, e.g., <code>% (hat|lov)ed? % %</code> finds all the phrases with <code>love</code>, <code>loved</code>, <code>hate</code>, and <code>hated</code>.</li>
<li><strong>Joins7:</strong> Spark supports SQL-style joins and this exercise provides a simple example.</li>
<li><strong>SparkStreaming8:</strong> The streaming capability is relatively new and this exercise shows how it works to construct a simple "echo" server. Running it is a little more involved. See below.</li>
</ul>


<p>Let's now work through these exercises...</p>

</div><div><h2>Intro1:</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/Intro1.sc">Intro1.sc</a></p>

<p>Our first exercise demonstrates the useful <em>Spark Shell</em>, which is a customized version of Scala's REPL (read, eval, print, loop). We'll copy and paste some commands from the file <a class="shortcut" href="#code/src/main/scala/spark/Intro1.sc">Intro1.sc</a>.</p>

<p>The comments in this and the subsequent files try to explain the API calls being made.</p>

<p>You'll note that the extension is <code>.sc</code>, not <code>.scala</code>. This is my convention to prevent the build from compiling this file, which won't compile because it's missing some definitions that the Spark Shell will define automatically.</p>

<p>Actually, we're <em>not</em> going to use the <em>actual</em> Spark Shell, because we just pull down the Spark JAR files as dependencies and not a full distribution. So, instead we'll just use the Scala REPL via the <code>sbt console</code> task. We'll discuss the differences of this approach.</p>

<p>You'll have to use a command window and <code>sbt</code> for this part of the workshop. If you're just interested in using Activator and not using <code>sbt</code>, then read through this section, but you can safely skip doing the exercise.</p>

<p>Change your working directory to where you installed this workshop and type <code>sbt</code>:</p>

<pre><code>cd where_you_installed_the_workshop
sbt
</code></pre>

<p>At the <code>sbt</code> prompt, type <code>console</code>. You'll see a welcome message and a <code>scala&gt;</code> prompt.</p>

<p>We're going to paste in the code from <a class="shortcut" href="#code/src/main/scala/spark/Intro1.sc">Intro1.sc</a>. You could do it all at once, but we'll do it a few lines at a time and discuss each one. Here is the content of the script without the comments, but broken into sections with discussions:</p>

<pre><code>import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._
val sc = new SparkContext("local", "Intro (1)")
</code></pre>

<p>Import the <code>SparkContext</code> that drives everything.</p>

<p>Why are there two, very similar <code>import</code> statements? The first one imports the <code>SparkContext</code> type so we don't have to use a fully-qualified name in the <code>new SparkContext</code> statement. The second is analogous to a <code>static import</code> in Java, where we make some methods and values visible in the current scope, again without requiring qualification.</p>

<p>When you construct a <code>SparkContext</code>, there are several constructors you can use. This one takes a string for the "master" and a job name. The master must be one of the following:</p>

<ul>
<li><code>local</code>: Start the Spark job standalone and use a single thread to run the job.</li>
<li><code>local[k]</code>: Use <code>k</code> threads instead. Should be less than the number of cores.</li>
<li><code>mesos://host:port</code>: Connect to a running, Mesos-managed Spark cluster.</li>
<li><code>spark://host:port</code>: Connect to a running, standalone Spark cluster.</li>
</ul>


<p>You can also run Spark under Hadoop YARN, which we'll discuss at the end of the workshop.</p>

<pre><code>val input = sc.textFile("data/kjvdat.txt").map(line =&gt; line.toLowerCase)
input.cache
</code></pre>

<p>Define a read-only variable <code>input</code> of type RDD (inferred) by loading the text of the King James Version of the Bible, which has each verse on a line, we then map over the lines converting the text to lower case.</p>

<blockquote><p>The <code>data</code> directory has a <a href="data/README.html">README</a> that discusses the files present and where they came from.</p></blockquote>

<p>Finally, we cache the data in memory for faster, repeated retrieval. You shouldn't always do this, as it consumes memory, but when your workflow will repeatedly reread the data, caching provides dramatic performance improvements.</p>

<pre><code>val sins = input.filter(line =&gt; line.contains("sin"))
val count = sins.count()         // How many sins?
val array = sins.collect()       // Convert the RDD into a collection (array)
array.take(20) foreach println   // Take the first 20, and print them 1/line.
</code></pre>

<p>Filter the input for just those verses that mention "sin" (recall that the text is now lower case). Then count how many found, convert the RDD to a collection. (What is the actual type??) and finally print the first twenty lines.</p>

<p>Note: in Scala, the <code>()</code> in method calls are actually optional for no-argument methods.</p>

<pre><code>val filterFunc: String =&gt; Boolean = 
    (s:String) =&gt; s.contains("god") || s.contains("christ") 
</code></pre>

<p>An alternative approach; create a separate filter <em>function value</em> instead and pass it as an argument to the filter method. Specifically, <code>filterFunc</code> is a value that's a function of type <code>String</code> to <code>Boolean</code>.</p>

<p>Actually, the following more concise form is equivalent, due to type inference:</p>

<pre><code>val filterFunc: String =&gt; Boolean = 
    s =&gt; s.contains("god") || s.contains("christ") 
</code></pre>

<pre><code>val sinsPlusGodOrChrist  = sins filter filterFunc
val countPlusGodOrChrist = sinsPlusGodOrChrist.count
</code></pre>

<p>Now use <code>filterFunc</code> with filter to find all the <code>sins</code> verses that mention God or Christ.
Then, count how many were found. Note that we dropped the parentheses after "count" in this case.</p>

<pre><code>sc.stop()
</code></pre>

<p>Stop the session. If you exit the REPL immediately, this will happen implicitly, but as we'll see, it's a good practice to always do this in your scripts. You'll also don't typically do this when running the actual Spark Shell, as you'll usually want the context alive until you're finished completely.</p>

<p>Lastly, we need to run some unrelated code to setup the rest of the exercises. Namely, we need to create an <code>output</code> directory we'll use:</p>

<pre><code>val output = new java.io.File("output")
if (output.exists == false) output.mkdir
</code></pre>

<p>Now, if we actually used the Spark Shell for this exercise, we would have omitted the two <code>import</code> statements and the statement where we created the <code>ScalaContext</code> value <code>sc</code>.
The shell automatically does these steps for us.</p>

<p>There are comments at the end of each source file, including this one, with suggested exercises to learn the API. Try them as time permits. Solutions for some of them are provided in the <code>src/main/scala/spark/solns</code> directory. Solutions are provided for all the suggested exercises, but we do accept pull requests ;) All the solutions provided for the rest of the exercises are also built with the rest of the code, so you'll be able to run them the same way.</p>

<blockquote><p>Note: If you don't want to modify the original code when working on an exercise, just copy the file and give the exercise type a new name.</p></blockquote>

<p>Before moving on, let's discuss how you would actually run the Spark Shell. When you <a href="TODO">download a full Spark distribution</a>, it includes a <code>bin</code> directory with several Bach shell and Windows scripts. All you need to do from a command window is invoke the command <code>bin/spark-shell</code> (assuming your working directory is the root of the distribution).</p>

</div><div><h2>WordCount2:</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/WordCount2.scala">WordCount2.scala</a></p>

<p>The classic, simple <em>Word Count</em> algorithm is easy to understand and it's suitable for parallel computation, so it's a good vehicle when first learning a Big Data API.</p>

<p>In <em>Word Count</em>, you read a corpus of documents, tokenize each one into words, and count the occurrences of all the words globally. The initial reading, tokenization, and "local" counts can be done in parallel.</p>

<p><a class="shortcut" href="#code/src/main/scala/spark/WordCount2.scala">WordCount2.scala</a> uses the same King James Version (KJV) of the Bible file we used in the first exercise. (Subsequent exercises will add the ability to override defaults with command-line arguments.)</p>

<p>If using the <a class="shortcut" href="#run">run</a> panel, select <code>scala.WordCount2</code> and click the "Start" button. The "Logs" panel shows some information. Note the "output" directories listed in the output. Use a file browser to find those directories (which have a timestamp) to view the output written in there.</p>

<p>If using <code>sbt</code>, enter <code>run</code> and then the number shown to the left to <code>scala.WordCount2</code>.</p>

<p>The reason the output directories have a timestamp in their name is so you can easily rerun the exercises repeatedly. Starting with v1.0.0, Spark follows the Hadoop convention of refusing to overwrite an existing directory. The timestamps keep them unique.</p>

<p>As before, here is the text of the script in sections, with code comments removed:</p>

<pre><code>package spark    // Put the code in a package named "spark"
import spark.util.Timestamp   // Simple date-time utility
import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._
</code></pre>

<p>We use a <code>spark</code> package for the compiled exercises. The <code>Timestamp</code> class is a simple utility class we implemented to create the timestamps we embed in put output file and directory names.</p>

<blockquote><p>Even though our exercises from now on will be compiled classes, you could still use the Spark Shell to try out most constructs. This is especially useful when debugging and experimenting!</p></blockquote>

<p>First, here is the outline of the script, demonstrating a pattern we'll use throughout.</p>

<pre><code>object WordCount2 {
  def main(args: Array[String]) = {

    val sc = new SparkContext("local", "Word Count (2)")

    try {
      ...
    } finally {
      sc.stop()      // Stop (shut down) the context.
    }
  }
}
</code></pre>

<p>In case the script fails with an exception, putting the <code>SparkContext.stop()</code> inside a <code>finally</code> clause ensures that will get invoked no matter what happens.</p>

<p>The content of the <code>try</code> clause is the following:</p>

<pre><code>val input = sc.textFile("data/kjvdat.txt").map(line =&gt; line.toLowerCase)
input.cache

val wc = input
  .flatMap(line =&gt; line.split("""\W+"""))
  .map(word =&gt; (word, 1))
  .reduceByKey((count1, count2) =&gt; count1 + count2)

val now = Timestamp.now()
val out = s"output/kjv-wc2-$now"
println(s"Writing output to: $out")
wc.saveAsTextFile(out)
</code></pre>

<p>After the same loading and cache of the data we saw previously, we setup a pipeline of operations to perform the word count.</p>

<p>First the line is split into words using as the separator any run of characters that isn't alphanumeric (e.g., whitespace and punctuation). This also conveniently removes the trailing <code>~</code> characters at the end of each line (for some reason). <code>input.flatMap(line =&gt; line.split(...))</code> maps over each line, expanding it into a collection of words, yielding a collection of collections of words. The <code>flat</code> part flattens those nested collections into a single, "flat" collection of words.</p>

<p>The next two lines convert the single word "records" into tuples with the word and a count of <code>1</code>. In Shark, the first field in a tuple will be used as the default key for joins, group-bys, and the <code>reduceByKey</code> we use next. It effectively groups all the tuples together with the same word (the key) and then "reduces" the values using the passed in function. In this case, the two counts are added together.</p>

<p>The last sequence of statements creates a timestamp that can be used in a file or directory name, constructs the output path, and finally uses the <code>saveAsTextFile</code> method to write the final RDD to that location.</p>

<p>Spark follows Hadoop conventions. The <code>out</code> path is actually interpreted as a directory name. Here is its contents (for a run at a particular time...):</p>

<pre><code>$ ls -Al output/kjv-wc2-2014.05.02-06.40.55
total 328
-rw-r--r--  1 deanwampler  staff       8 May  3 09:40 ._SUCCESS.crc
-rw-r--r--  1 deanwampler  staff    1248 May  3 09:40 .part-00000.crc
-rwxrwxrwx  1 deanwampler  staff       0 May  3 09:40 _SUCCESS
-rwxrwxrwx  1 deanwampler  staff  158620 May  3 09:40 part-00000
</code></pre>

<p>In a real cluster with lots of data and lots of concurrent processing, there would be many <code>part-NNNNN</code> files. They contain the actual data. The <code>_SUCCESS</code> file is a useful convention that signals the end of processing. It's useful because tools that are watching for the data to be written so they can perform subsequent processing will know the files are complete when they see this marker file. Finally, there are "hidden" CRC files for these other two files.</p>

<p>There are exercises in the file and solutions for some of them, for example <a class="shortcut" href="#code/src/main/scala/spark/solns/WordCount2GroupBy.scala">solns/WordCount2GroupBy.scala</a> solves a "group by" exercise.</p>

</div><div><h2>WordCount3:</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/WordCount3.scala">WordCount3.scala</a></p>

<p>This exercise also implements <em>Word Count</em>, but it uses a slightly simpler approach. It also uses a utility library we added to handle input command-line arguments, demonstrating some idiomatic (but fairly advanced) Scala code.</p>

<p>Finally, it does some data cleansing to improve the results. The sacred text files included in the <code>data</code> directory, such as <code>kjvdat.txt</code> are actually formatted records of the form:</p>

<pre><code>book|chapter|verse|text
</code></pre>

<p>That is, pipe-separated fields with the book of the Bible (e.g., Genesis, but abbreviated "Gen"), the chapter and verse numbers, and then the verse text. We just want to word count the verses, although including the book names would be fine.</p>

<p>Command line options can be used to override the defaults. You'll have to use <code>sbt</code> from a command window to use this feature. Note the use of the <code>run-main</code> task that lets us specify a particular "main" to run and optional arguments. The "\" are used to wrap long lines, <code>[...]</code> indicate optional arguments, and <code>|</code> indicate alternative flags:</p>

<pre><code>run-main spark.WordCount3 [ -h | --help] \ 
  [-i | --in | --inpath input] \ 
  [-o | --out | --outpath output] \ 
  [-m | --master master] \ 
  [-q | --quiet]
</code></pre>

<p>Where the options have the following meanings:</p>

<pre><code>-h | --help     Show help and exit.
-i ... input    Read this input source (default: data/kjvdat.txt).
-o ... output   Write to this output location (default: output/kjvdat-wc3).
-m ... master   local, local[k], etc. as discussed previously.
-q | --quiet    Suppress some informational output.
</code></pre>

<p>You can try different variants of <code>local[k]</code>, but keep k less than the number of cores in your machine. The <code>input</code> and <code>master</code> arguments are basically the same things we discussed for <code>WordCount2</code>, but the <code>output</code> argument is used slightly differently. As we'll see, we'll output the results using a different mechanism than before, so the <code>output/kjvdat-wc3</code> (or your override) will be converted to file (not a Hadoop-style directory) <code>output/kjvdat-wc3-${now}.txt</code>, where <code>${now}</code> will be replaced with the current timestamp. The <code>quiet</code> option is mostly for the automated tests benefit.</p>

<p>When you specify an input path for Spark, you can specify <code>bash</code>-style "globs" and even a list of them.</p>

<ul>
<li><code>data/foo</code>: Just the file <code>foo</code> or if it's a directory, all its files, one level deep (unless the program does some extra handling itself).</li>
<li><code>data/foo*.txt</code>: All files in <code>data</code> whose names start with <code>foo</code> and end with the <code>.txt</code> extension.</li>
<li><code>data/foo*.txt,data2/bar*.dat</code>: A comma-separated list of globs.</li>
</ul>


<p>Here is the implementation of <code>WordCount3</code>, in sections:</p>

<pre><code>package spark
import spark.util.{CommandLineOptions, Timestamp}
import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._
</code></pre>

<p>As before, but with our new <code>CommandLineOptions</code> and <code>Timestamp</code> utilities.</p>

<pre><code>object WordCount3 {
  def main(args: Array[String]) = {

    val options = CommandLineOptions(
      this.getClass.getSimpleName,
      CommandLineOptions.inputPath("data/kjvdat.txt"),
      CommandLineOptions.outputPath("output/kjv-wc3"),
      CommandLineOptions.master("local"),
      CommandLineOptions.quiet)

    val argz = options(args.toList)
</code></pre>

<p>I won't discuss the implementation of <a class="shortcut" href="#code/src/main/scala/spark/util/CommandLineOptions.scala">CommandLineOptions.scala</a> except to say that it defines some methods that create instances of an <code>Opt</code> type, one for each of the options we discussed above. The single argument to this method is the default value.</p>

<pre><code>    val sc = new SparkContext(argz("master").toString, "Word Count (3)")

    try {
      val input = sc.textFile(argz("input-path").toString)
        .map(line =&gt; line.toLowerCase.split("\\s*\\|\\s*").last)
      input.cache
</code></pre>

<p>It starts out much like <code>WordCount2</code>, but it splits each line into fields, where the lines are of the form: <code>book|chapter|verse|text</code>. Only the text is kept. The output is an RDD that we then cache as before. Note that calling <code>last</code> on the split array is robust against lines that don't have the delimiter, if there are any; it simply returns the whole original string.</p>

<pre><code>      val wc2 = input
        .flatMap(line =&gt; line.split("""\W+"""))
        .countByValue()  // Returns a Map[T, Long]
</code></pre>

<p>Split on non-alphanumeric sequences of character as before, but rather than map to <code>(word, 1)</code> tuples and use <code>reduceByKey</code>, as we did in <code>WordCount2</code>, we simply treat the words as values and call <code>countByValue</code> to count the unique occurrences.</p>

<pre><code>      val now = Timestamp.now()
      val outpath = s"${argz("output-path")}-$now"
      if (argz("quiet").toBoolean == false) 
        println(s"Writing output (${wc2.size} records) to: $outpath")

      import java.io._
      val out = new PrintWriter(outpath)
      wc2 foreach {
        case (word, count) =&gt; out.println("%20s\t%d".format(word, count))
      }
      // WARNING: Without this close statement, it appears the output stream is 
      // not completely flushed to disk!
      out.close()
    } finally {
      sc.stop()
    }
  }
}
</code></pre>

<p>The result of <code>countByValue</code> is a Scala array, not an RDD, so we use conventional Java I/O to write the output. Note the warning; failure to close the stream explicit appears to cause data truncation when the <code>SparkContext</code> is stopped before the stream is flushed.</p>

<p>Don't forget the try the exercises at the end of the source file.</p>

</div><div><h2>Matrix4</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/Matrix4.scala">Matrix4.scala</a></p>

<p>Spark was originally used for Machine Learning algorithms. It has a built-in Matrix API that is useful for many machine learning algorithms. This exercise explores it briefly.</p>

<p>The sample data is generated internally; there is no input that is read. The output is written to the console.</p>

<p>Here is the <code>run-main</code> command with options:</p>

<pre><code>run-main spark.Matrix4 [m [n]]
</code></pre>

<p>Where the smaller set of supported options are:</p>

<pre><code>m   Number of rows (default: 5)
n   Number of columns (default: 10)
</code></pre>

<p>Here is the code:</p>

<pre><code>package spark
import spark.util.{Matrix, Timestamp}
import org.apache.spark.SparkContext

object Matrix4 {

  // Override for tests.
  var out = Console.out

  def main(args: Array[String]) = {

    case class Dimensions(m: Int, n: Int)

    val dims = args match {
      case Array(m, n) =&gt; Dimensions(m.toInt, n.toInt)
      case Array(m)    =&gt; Dimensions(m.toInt, 10)
      case Array()     =&gt; Dimensions(5,       10)
      case _ =&gt; 
        println("""Expected optional matrix dimensions, got this: ${args.mkString(" ")}""")
        sys.exit(1)
    }
</code></pre>

<p><code>Dimensions</code> is a convenience class for capturing the default or user-specified matrix dimensions.</p>

<pre><code>    val sc = new SparkContext("local", "Matrix (4)")

    try { 
      // Set up a mxn matrix of numbers.
      val matrix = Matrix(dims.m, dims.n)

      // Average rows of the matrix in parallel:
      val sums_avgs = sc.parallelize(1 to dims.m).map { i =&gt;
        // Matrix indices count from 0. 
        // "_ + _" is the same as "(count1, count2) =&gt; count1 + count2".
        val sum = matrix(i-1) reduce (_ + _) 
        (sum, sum/dims.n)
      }.collect

      out.println(s"${dims.m}x${dims.n} Matrix:")
      sums_avgs.zipWithIndex foreach {
        case ((sum, avg), index) =&gt; 
          out.println(f"Row #${index}%2d: Sum = ${sum}%4d, Avg = ${avg}%3d")
      }
    } finally {
      sc.stop()
    }
  }
}
</code></pre>

<p>The comments explain most of the steps. The crucial part is the call to <code>parallelize</code> that creates N parallel operations. If you have less than N cores, some of the operations will have to run sequentially. The argument to <code>parallelize</code> is a sequence of "things" where each one will be passed to one of the operations. Here, we just use the literal syntax to construct a sequence of integers from 1 to the number of rows. When the anonymous function is called, one of those row numbers will get assigned to <code>i</code>. We then grab the <code>i-1</code> row (because of zero indexing) and use the <code>reduce</code> method to sum the column elements. A final tuple with the sum and the average is returned.</p>

<p>The <code>collect</code> method is called to convert the RDD to an array, because we're just going to print results to the console. The expression <code>sums_avgs.zipWithIndex</code> creates a tuple with each <code>sumb_avgs</code> value and it's index into the collection. We use that to print the row index.</p>

</div><div><h2>Crawl5a</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/Crawl5a.scala">Crawl5a.scala</a></p>

<p>This the first part of the fifth exercise. It simulates a web crawler that builds an index of documents to words, the first step for computing the <em>inverse index</em> used by search engines, from words to documents. The documents "crawled" are sample emails from the Enron email dataset, each of which has been previously classified already as SPAM or HAM.</p>

<p><code>Crawl5a</code> supports the same command-line options as <code>WordCount3</code>:</p>

<pre><code>run-main spark.Crawl5a [ -h | --help] \ 
  [-i | --in | --inpath input] \ 
  [-o | --out | --outpath output] \ 
  [-m | --master master] \ 
  [-q | --quiet]
</code></pre>

<p>In this case, no timestamp is appended to the output path, since it will be read by the next exercise <code>InvertedIndex5b</code>. So, if you rerun <code>Crawl5a</code>, you'll have to delete or rename the previous output manually.</p>

<p>Most of this code is straightforward. It's comments explain any complicated constructs used.</p>

</div><div><h2>InvertedIndex5b</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/InvertedIndex5b.scala">InvertedIndex5b.scala</a></p>

<p>Using the crawl data just generated, compute the index of words to documents (emails).</p>

<p><code>InvertedIndex5b</code> supports the same command-line options as <code>WordCount3</code>:</p>

<pre><code>run-main spark.InvertedIndex5b [ -h | --help] \ 
  [-i | --in | --inpath input] \ 
  [-o | --out | --outpath output] \ 
  [-m | --master master] \ 
  [-q | --quiet]
</code></pre>

<p>Here is the code:</p>

<pre><code>package spark

import spark.util.{CommandLineOptions, Timestamp}
import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._

object InvertedIndex5b {
  def main(args: Array[String]) = {

    val options = CommandLineOptions(
      this.getClass.getSimpleName,
      CommandLineOptions.inputPath("output/crawl"),
      CommandLineOptions.outputPath("output/inverted-index"),
      CommandLineOptions.master("local"),
      CommandLineOptions.quiet)

    val argz = options(args.toList)

    val sc = new SparkContext(argz("master").toString, "Inverted Index (5b)")

    try {
      val lineRE = """^\s*\(([^,]+),(.*)\)\s*$""".r
      val input = sc.textFile(argz("input-path").toString) map {
        case lineRE(name, text) =&gt; (name.trim, text.toLowerCase)
        case badLine =&gt; 
          Console.err.println("Unexpected line: $badLine")
          ("", "")  
      }
</code></pre>

<p>Inside the <code>try</code> expression, we load the "crawl" data, where each line was written by <code>Crawl5a</code> with the following format: <code>(document_id, text)</code> (including the parentheses). Hence, we use a regular expression with "capture groups" for the document and text.</p>

<p>Note the function passed to <code>map</code>. It has the form:</p>

<pre><code>{
  case lineRE(name, text) =&gt; ...
  case line =&gt; ...
}
</code></pre>

<p>There is now explicit argument list like we've used before. This syntax is the literal syntax for a <em>partial function</em>, a mathematical concept for a function that is not defined at all of its inputs. We have two <code>case</code> match clauses, one for when the regular expression successfully matches and returns the capture groups into variables <code>name</code> and <code>text</code> and the second which will match everything else, assigning the line to the variable <code>badLine</code>. (In fact, this catch-all clause makes the function <em>total</em>, not <em>partial</em>.) The function must return a two-element tuple, so the catch clause simply returns <code>("","")</code>.</p>

<p>Note that the specified or default <code>input-path</code> is a directory with Hadoop-style content, as discussed previously. Spark knows to ignore the "hidden" files.</p>

<pre><code>      val now = Timestamp.now()
      val out = s"${argz("output-path")}-$now"
      if (argz("quiet").toBoolean == false) 
        println(s"Writing output to: $out")

      // Split on non-alphanumeric sequences of character as before. 
      // Rather than map to "(word, 1)" tuples, we treat the words by values
      // and count the unique occurrences.
      input
        .flatMap { 
          case (path, text) =&gt; text.split("""\W+""") map (word =&gt; (word, path))
        }
        .map { 
          case (word, path) =&gt; ((word, path), 1) 
        }
        .reduceByKey{
          case (count1, count2) =&gt; count1 + count2
        }
        .map {
          case ((word, path), n) =&gt; (word, (path, n)) 
        }
        .groupBy {
          case (word, (path, n)) =&gt; word
        }
        .map {
          case (word, seq) =&gt; 
            val seq2 = seq map {
              case (redundantWord, (path, n)) =&gt; (path, n)
            }
            (word, seq2.mkString(", "))
        }
        .saveAsTextFile(out)
    } finally {
      sc.stop()
    }
  }
}
</code></pre>

<p>See if you can understand what this sequence of transformations is doing. The end goal is to output each record string in the following form: <code>(word, (doc1, n1), (doc2, n2), ...)</code>:</p>

</div><div><h2>NGrams6</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/NGrams6.scala">NGrams6.scala</a></p>

<p>In <em>Natural Language Processing</em>, one goal is to determine the sentiment or meaning of text. One technique that helps do this is to locate the most frequently-occurring, N-word phrases, or <em>NGrams</em>. Longer NGrams can convey more meaning, but they occur less frequently so all of them appear important. Shorter NGrams have better statistics, but each one conveys less meaning. In most cases, N=3-5 appears to provide the optimal balance.</p>

<p>This exercise finds all NGrams matching a user-specified pattern. The default is the 4-word phrases the form <code>% love % %</code>, where the <code>%</code> are wild cards. In other words, all 4-grams are found with <code>love</code> as the second word. The <code>%</code> are conveniences; the user can also specify an NGram Phrase that is a regular expression or a mixture, e.g., <code>% (hat|lov)ed? % %</code> finds all the phrases with <code>love</code>, <code>loved</code>, <code>hate</code>, or <code>hated</code> as the second word.</p>

<p><code>NGrams6</code> supports the same command-line options as <code>WordCount3</code>, except for the output path (it just writes to the console), plus two new options:</p>

<pre><code>run-main spark.NGrams6 [ -h | --help] \ 
  [-i | --in | --inpath input] \ 
  [-m | --master master] \ 
  [-c | --count N] \ 
  [-n | --ngrams string] \ 
  [-q | --quiet]
</code></pre>

<p>Where</p>

<pre><code>-c | --count N        List the N most frequently occurring NGrams (default: 100)
-n | --ngrams string  Match string (default "% love % %"). Quote the string!
</code></pre>

<p>The <code>%</code> are wildcards for words and the whitespace is replaced with a more general regular expression. You can specify regular expressions if you want. What would the following match?</p>

<pre><code>-n "% (lov|hat)ed? % %"
</code></pre>

<p>Here r yur codez:</p>

<pre><code>package spark

import spark.util.{CommandLineOptions, Timestamp}
import spark.util.CommandLineOptions.Opt
import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._

object NGrams6 {

  // Override for tests.
  var out = Console.out

  def main(args: Array[String]) = {

    /** A function to generate an Opt for handling the count argument. */
    def count(value: String): Opt = Opt(
      name   = "count",
      value  = value,
      help   = s"-c | --count  N  The number of NGrams to compute (default: $value)",
      parser = {
        case ("-c" | "--count") +: n +: tail =&gt; (("count", n), tail)
      })

    /** 
     * The NGram phrase to match, e.g., "I love % %" will find 4-grams that 
     * start with "I love", and "% love %" will find trigrams with "love" as the
     * second word.
     * The "%" are replaced by the regex "\w+" and whitespace runs are replaced
     * with "\s+" to create a matcher regex.
     */
    def ngrams(value: String): Opt = Opt(
      name   = "ngrams",
      value  = value,
      help   = s"-n | --ngrams  S     The NGrams match string (default: $value)",
      parser = {
        case ("-n" | "--ngrams") +: s +: tail =&gt; (("ngrams", s), tail)
      })

    val options = CommandLineOptions(
      this.getClass.getSimpleName,
      CommandLineOptions.inputPath("data/kjvdat.txt"),
      CommandLineOptions.master("local"),
      CommandLineOptions.quiet,
      count("100"),
      ngrams("% love % %"))

    val argz = options(args.toList)

    val sc = new SparkContext(argz("master").toString, "NGrams (6)")
    val ngramsStr = argz("ngrams").toString.toLowerCase
    // Note that the replacement strings use Scala's triple quotes; necessary
    // to ensure that the final string is "\w+" and "\s+" for the reges.
    val ngramsRE = ngramsStr.replaceAll("%", """\\w+""").replaceAll("\\s+", """\\s+""").r
    val n = argz("count").toInt
</code></pre>

<p>Without discussing the details, this exercise defines two new <code>Opt</code> instances for handling the NGram phrase and count options. Because we allow the user to mix <code>%</code> characters for word wildcards and regular expressions, we convert the <code>%</code> to regexs for words and also replace all runs of whitespace with a more flexible regex for whitespace.</p>

<pre><code>    try {
      object CountOrdering extends Ordering[(String,Int)] {
        def compare(a:(String,Int), b:(String,Int)) = 
          -(a._2 compare b._2)  // - so that it sorts descending
      }

      val ngramz = sc.textFile(argz("input-path").toString)
        .flatMap { line =&gt; 
            val text = line.toLowerCase.split("\\s*\\|\\s*").last
            ngramsRE.findAllMatchIn(text).map(_.toString)
        }
        .map(ngram =&gt; (ngram, 1))
        .reduceByKey((count1, count2) =&gt; count1 + count2)
        .takeOrdered(n)(CountOrdering)

      out.println(s"Found ${ngramz.size} ngrams:")
      ngramz foreach {
        case (ngram, count) =&gt; out.println("%30s\t%d".format(ngram, count))
      }
    } finally {
      sc.stop()
    }
  }
}
</code></pre>

<p>We need an implementation of <code>Ordering</code> to sort our found NGrams descending by count.
We read the data as before, but note that because of our line orientation, we <em>won't</em> find NGrams that cross line boundaries! This doesn't matter for our sacred text files, since it wouldn't make sense to find NGrams across verse boundaries, but a more flexible implementation should account for this. Note that we also look at just the verse text, as in <code>WordCount3</code>.</p>

<p>The <code>map</code> and <code>reduceByKey</code> calls are just like we used previously for <code>WordCount2</code>, but now we're counting found NGrams. The final <code>takeOrdered</code> call combines sorting with taking the top <code>n</code> found. This is more efficient than separate sort, then take operations. As a rule, when you see a method that does two things like this, it's usually there for efficiency reasons!</p>

</div><div><h2>Joins7</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/Joins7.scala">Joins7.scala</a></p>

<p>Joins are a familiar concept in databases and Spark supports them, too. Joins at very large scale can be quite expensive, although a number of optimizations have been developed, some of which require programmer intervention to use. We won't discuss the details here, but it's worth reading how joins are implemented in various <em>Big Data</em> systems, such as <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins#LanguageManualJoins-JoinOptimization">this discussion for Hive joins</a> and the <strong>Joins</strong> section of <a href="http://shop.oreilly.com/product/0636920021773.do">Hadoop: The Definitive Guide</a>.</p>

<p>Here, we will join the KJV Bible data with a small "table" that maps the book abbreviations to the full names, e.g., <code>Gen</code> to <code>Genesis</code>.</p>

<p><code>Joins7</code> supports the following command-line options:</p>

<pre><code>run-main spark.Joins7 [ -h | --help] \ 
  [-i | --in | --inpath input] \ 
  [-o | --out | --outpath output] \ 
  [-m | --master master] \ 
  [-a | --abbreviations path] \ 
  [-q | --quiet]
</code></pre>

<p>Where the <code>--abbreviations</code> is the path to the file with book abbreviations to book names. It defaults to <code>data/abbrevs-to-names.tsv</code>. Note that the format is tab-separated values, which the script must handle correctly.</p>

<p>Here r yur codez:</p>

<pre><code>object Joins7 {
  def main(args: Array[String]) = {

    /** The "dictionary" of book abbreviations to full names */
    val abbrevsFile = "data/abbrevs-to-names.tsv"
    val abbrevs = Opt(
      name   = "abbreviations",
      value  = abbrevsFile,
      help   = s"-a | --abbreviations  path The dictionary of book abbreviations to full names (default: $abbrevsFile)",
      parser = {
        case ("-a" | "--abbreviations") +: path +: tail =&gt; (("abbreviations", path), tail)
      })

    val options = CommandLineOptions(
      this.getClass.getSimpleName,
      CommandLineOptions.inputPath("data/kjvdat.txt"),
      abbrevs,
      CommandLineOptions.outputPath("output/kjv-joins"),
      CommandLineOptions.master("local"),
      CommandLineOptions.quiet)

    val argz = options(args.toList)

    val sc = new SparkContext(argz("master").toString, "Joins (7)")
</code></pre>

<p>The input sacred text (default: <code>data/kjvdat.txt</code>) is assumed to have the format <code>book|chapter|verse|text</code>:</p>

<pre><code>    try {
      val input = sc.textFile(argz("input-path").toString)
        .map { line =&gt; 
          val ary = line.split("\\s*\\|\\s*")
          (ary(0), (ary(1), ary(2), ary(3)))
        }
</code></pre>

<p>Note the output tuple format from the <code>map</code>. For joins, Spark wants a <code>(key,value)</code> tuple, so we use a nested tuple for the chapter, verse, and text. The abbreviations file is handled similarly, but the delimiter is a tab:</p>

<pre><code>      val abbrevs = sc.textFile(argz("abbreviations").toString)
        .map{ line =&gt; 
          val ary = line.split("\\s+", 2)
          (ary(0), ary(1).trim)  // I've noticed trailing whitespace...
        }
</code></pre>

<p>Note the second argument to <code>split</code>. Just in case a full book name has a nested tab, we explicitly only want to split on the first tab found, yielding two strings.</p>

<pre><code>      // Cache both RDDs in memory for fast, repeated access.
      input.cache
      abbrevs.cache

      // Join on the key, the first field in the tuples; the book abbreviation.

      val verses = input.join(abbrevs)

      if (input.count != verses.count) {
        println(s"input count, ${input.count}, doesn't match output count, ${verses.count}")
      }
</code></pre>

<p>We perform an inner join on the keys of each RDD and add a sanity check for the output. Since this is an inner join, the sanity check catches the case where an abbreviation wasn't found and the corresponding verses were dropped!</p>

<p>The schema of <code>verses</code> is this: <code>(key, (value1, value2))</code>, where <code>value</code> is <code>(chapter, verse, text)</code> from the KJV input and <code>value</code> is the full book name, the second "field" from the abbreviations file. We now flatten the records to the final desired form, <code>fullBookName|chapter|verse|text</code>:</p>

<pre><code>      val verses2 = verses map {
        // Drop the key - the abbreviated book name
        case (_, ((chapter, verse, text), fullBookName)) =&gt; 
          (fullBookName, chapter, verse, text)
      }
</code></pre>

<p>Lastly, we write the output:</p>

<pre><code>      val now = Timestamp.now()
      val out = s"${argz("output-path")}-$now"
      if (argz("quiet").toBoolean == false) 
        println(s"Writing output to: $out")
      verses2.saveAsTextFile(out)
    } finally {
      sc.stop()
    }
  }
}
</code></pre>

<p>The <code>join</code> method we used is implemented by <a href="http://spark.apache.org/docs/1.0.0/api/scala/index.html#org.apache.spark.rdd.PairRDDFunctions">spark.rdd.PairRDDFunctions</a>, with many other methods for computing "co-groups", outer joins, etc.</p>

</div><div><h2>SparkStreaming8</h2>

<p><a class="shortcut" href="#code/src/main/scala/spark/SparkStreaming8.scala">SparkStreaming8.scala</a></p>

<p>The streaming capability is relatively new and our last exercise shows how it works to construct a simple "echo" server. It has two running modes. The default mode just reads the contents of a file (the KJV Bible file, by default). That works best in Activator using the "run" command.</p>

<p>In Activator or <code>sbt</code>, run <code>SparkStreaming8</code> as we've done for the other exercises. It will read the KJV Bible text file, then terminate after 5 seconds, because otherwise the app will run forever, waiting for a changed text file to appear!</p>

<p>Alternatively, the app can receive text over a socket connection. We'll use a console network app to send data to the spark streaming process, either the <code>nc</code> console app that's part of <a href="http://netcat.sourceforge.net/">NetCat</a> or the <code>NCat</code> app that comes with <a href="http://nmap.org/download.html">NMap</a>, which is available for more platforms, like Windows. If you're on a Mac or Linux machine, you probably already have <code>nc</code> installed.</p>

<p>To try the app with a socket connection, open a second console window to use <code>nc</code> or <code>ncat</code>. Then, run this <code>nc</code> command (or the equivalent for <code>ncat</code>):</p>

<pre><code>nc -c -l -p 9999
</code></pre>

<p>The <code>-c</code> option (which could be omitted) tells it to terminate if the socket drops, the <code>-l</code> option puts <code>nc</code> into listen mode, and the <code>-p</code> option is used to specify the port.</p>

<p>If you've been using Activator, open another console/shell window and change to the project directory. If you've been using <code>sbt</code>, just use the same session. Run <code>SparkStreaming8</code> with the following <code>sbt</code> command:</p>

<p>Note that it has default arguments for the host (<code>localhost</code>) and the port (<code>9999</code>), e.g., you could use this <code>sbt</code> command to override them:</p>

<pre><code>run-main spark.SparkStreaming8 --socket localhost:9999
</code></pre>

<p>Back to the <code>nc</code> console, type (or copy and paste) text into the window. After each carriage return, the text is sent to the <code>SparkStreaming8</code> app, where word count is performed on it and some output is written to that app's console window.</p>

<p>Once again, <code>SparkStreaming8</code> will terminate after 5 seconds, because otherwise the app will try to run forever!</p>

<p>However, it does detect if the socket connection drops, e.g., you hit <code>^C</code> in the <code>nc</code> window. It will take a few moments to shut itself down. The app has a "listener" that
will shutdown when the socket drops. However, by default, Spark Streaming will attempt to re-establish the connection, which is probably what you would want in a long-running system.</p>

<p>The 5-second timeout is still on in the streaming scenario, but you can disable it when using either input mode by also passing the argument <code>--no-term</code> ("no terminate"):</p>

<pre><code>run-main spark.SparkStreaming8 --socket localhost:9999 --no-term
</code></pre>

<p>Restart <code>nc</code> in the other window and try this variant of <code>run-main</code>. After a few seconds, use <code>^C</code> to kill <code>nc</code> and watch the error messages generated in the <code>sbt</code> window. Note how long it takes for the application to shutdown.</p>

<p>You can use any <code>server:port</code> combination you want, even on a remote machine.</p>

<p>To recap, <code>SparkStreaming8</code> supports the following command-line options:</p>

<pre><code>run-main spark.SparkStreaming8 [ -h | --help] \ 
  [-i | --in | --inpath input] \ 
  [-s | --socket server:port] \ 
  [-n | --no | --no-term] \ 
  [-q | --quiet]
</code></pre>

<p>Where the default is <code>--inpath data/kjvdat.txt</code>.</p>

</div><div><h2>How Spark Streaming Works</h2>

<p>Spark Streaming uses a clever hack; it runs more or less the same Spark API (or code that at least looks conceptually the same) on <em>deltas</em> of data, say all the events received within 1-second intervals (which is what we used here). Those deltas are <code>RDDs</code> encapsulated in a <code>DStream</code> ("Discretized Stream").</p>

<p>A <code>StreamingContext</code> is used to wrap the normal <code>SparkContext</code>, too.</p>

</div><div><h2>The SparkStreaming8 Code</h2>

<p>Here is the code for <a class="shortcut" href="#code/src/main/scala/spark/SparkStreaming8.scala">SparkStreaming8.scala</a>:</p>

<pre><code>object SparkStreaming8 {
  // Override for tests, etc.
  var out = Console.out

  val timeout = 5 * 1000   // 5 seconds

  /** 
   * Use "--socket host:port" to listen for events. 
   * To read "events" from a directory of files instead, e.g., for testing,
   * use the "--inpath" argument.
   */
  def socket(hostPort: String): Opt = Opt(
    name   = "socket",
    value  = hostPort,
    help   = s"-s | --socket host:port  Listen to a socket for events (default: $hostPort unless --inpath used)",
    parser = {
      case ("-s" | "--socket") +: hp +: tail =&gt; (("socket", hp), tail)
    })

  /** 
   * Use "--no-term" to keep this process running "forever" (or until ^C). 
   */
  def noterm(): Opt = Opt(
    name   = "no-term",
    value  = "",  // ignored
    help   = s"-n | --no | --no-term  Run forever; don't terminate after $timeout seconds)",
    parser = {
      case ("-n" | "--no" | "--no-term") +: tail =&gt; (("no-term", "true"), tail)
    })

  case class EndOfStreamListener(sc: StreamingContext) extends StreamingListener {
    override def onReceiverError(error: StreamingListenerReceiverError):Unit = {
      out.println(s"Receiver Error: $error. Stopping...")
      sc.stop()
    }
    override def onReceiverStopped(stopped: StreamingListenerReceiverStopped):Unit = {
      out.println(s"Receiver Stopped: $stopped. Stopping...")
      sc.stop()
    }
  }
</code></pre>

<p>We define <code>Opt</code> objects for the new command-line options <code>--socket server:port</code> and <code>--no-term</code>.</p>

<p>The <code>EndOfStreamListener</code> will be used to detect when a socket connection drops. It will start the exit process. Note that it is not triggered when the end of file is reached while reading directories of files. In this case, we have to rely on the 5-second timeout to quit.</p>

<pre><code>  def main(args: Array[String]) = {

    val options = CommandLineOptions(
      this.getClass.getSimpleName,
      CommandLineOptions.inputPath("data/kjvdat.txt"),
      // We write to "out" instead of to a directory:
      // CommandLineOptions.outputPath("output/kjv-wc3"),  
      // For this process, use at least 2 cores!
      CommandLineOptions.master("local[2]"),
      socket(""),  // empty default, so we know the user specified this option.
      noterm(),
      CommandLineOptions.quiet)

    val argz = options(args.toList)
</code></pre>

<p>The usual command-line argument processing.</p>

<pre><code>    val conf = new SparkConf()
             .setMaster("local[2]")
             .setAppName("Spark Streaming (8)")
             .set("spark.cleaner.ttl", "60")
             .set("spark.files.overwrite", "true")
             // If you need more memory:
             // .set("spark.executor.memory", "1g")
    val sc  = new SparkContext(conf)
    val ssc = new StreamingContext(sc, Seconds(1))
    ssc.addStreamingListener(EndOfStreamListener(ssc))
</code></pre>

<p>Construct the <code>SparkContext</code> a different way, by first defining a <code>SparkConf</code> (configuration) object. First, it is necessary to use 2 cores, which is specified using <code>setMaster("local[2]")</code> to avoid a <a href="http://apache-spark-user-list.1001560.n3.nabble.com/streaming-questions-td3281.html">problem discussed here</a>.</p>

<p>Spark Streaming requires the TTL to be set, <code>spark.cleaner.ttl</code>, which defaults to infinite. This specifies the duration in seconds for how long Spark should remember any metadata, such as the stages and tasks generated, etc. Periodic clean-ups are necessary for long-running streaming jobs. Note that an RDD that persists in memory for more than this duration will be cleared as well. See <a href="http://spark.apache.org/docs/1.0.0/configuration.html">Configuration</a> for more details.</p>

<p>With the <code>SparkContext</code>, we create a <code>StreamingContext</code>, where we also specify the time interval. Finally, we add a listener for socket drops.</p>

<pre><code>    try {
      val lines = 
        if (argz("socket") == "") useDirectory(ssc, argz("input-path"))
        else useSocket(ssc, argz("socket"))
</code></pre>

<p>If a socket connection wasn't specified, then use the <code>input-path</code> to read from one or more files (the default case). Otherwise use a socket. An <code>InputDStream</code> is returned in either case as <code>lines</code>. The two methods <code>useDirectory</code> and <code>useSocket</code> are listed below.</p>

<p>From the <code>DStream</code> (Discretized Stream) that fronts either the socket or the files, an RDD will be periodically generated for each discrete chunk of (possibly empty) data in each 1-second interval.</p>

<p>Now we implement an incremental word count:</p>

<pre><code>      val words = lines.flatMap(line =&gt; line.split("""\W+"""))

      val pairs = words.map(word =&gt; (word, 1))
      val wordCounts = pairs.transform(rdd =&gt; rdd.reduceByKey(_ + _))

      wordCounts.print()  // print a few counts...

      // Generates a separate directory inside "out" each interval!!
      // val now = Timestamp.now()
      // val out = s"output/streaming/kjv-wc-$now"
      // println(s"Writing output to: $out")
      // wordCounts.saveAsTextFiles(out, "txt")

      ssc.start()
      if (argz("no-term") == "") ssc.awaitTermination(timeout)
      else  ssc.awaitTermination()
    } finally {
      // Having the ssc.stop here is only needed when we use the timeout.
      out.println("+++++++++++++ Stopping! +++++++++++++")
      ssc.stop()
    }
  }
</code></pre>

<p>This works much like our previous word count logic, except for the use of <code>transform</code>, a <code>DStream</code> method for transforming the <code>RDDs</code> into new <code>RDDs</code>. In this case, we are performing "mini-word counts", within each RDD, but not across the whole <code>DStream</code>.</p>

<p>Note that we comment out writing the results to files, as it creates a separate output directory <em>per interval</em> (1 second), most of which are empty for this example. However, it's worth uncommenting these lines for one run to see what's produced.</p>

<p>Lastly, we wait for termination. By default, we set a <code>timeout</code> of 5 seconds.</p>

<p>The app ends with <code>useSocket</code> and <code>useDirectory</code>:</p>

<pre><code>  private def useSocket(sc: StreamingContext, serverPort: String): DStream[String] = {
    try {
      // Pattern match to extract the 0th, 1st array elements after the split.
      val Array(server, port) = serverPort.split(":")
      out.println(s"Connecting to $server:$port...")
      sc.socketTextStream(server, port.toInt)
    } catch {
      case th: Throwable =&gt; 
        sc.stop()
        throw new RuntimeException(
          s"Failed to initialize host:port socket with host:port string '$serverPort':",
          th)
    }
  }

  // Hadoop text file compatible.
  private def useDirectory(sc: StreamingContext, dirName: String): DStream[String] = {
    out.println(s"Reading 'events' from directory $dirName")
    sc.textFileStream(dirName)
  }
}
</code></pre>

<p>This is just the tip of the iceberg for Streaming. See the <a href="http://spark.apache.org/docs/1.0.0/streaming-programming-guide.html">Streaming Programming Guide</a> for more information.</p>

</div><div><h2>Best Practices, Tips, and Tricks</h2>

<h3>Safe Closures</h3>

<p>When you use a closure (anonymous function), Spark will serialize it and send it around the cluster. This means that any captured variables must be serializable.</p>

<p>A common mistake is to capture a field in an object, which forces the whole object to be serialized. Sometimes it can't be. Consider this example adapted from <a href="http://spark-summit.org/wp-content/uploads/2013/10/McDonough-spark-tutorial_spark-summit-2013.pdf">this presentation</a>.</p>

<pre><code>class RDDApp {
  val factor = 3.14159
  val log = new Log(...)

  def multiply(rdd: RDD[Int]) = {
    rdd.map(x =&gt; x * factor).reduce(...)
  }
}
</code></pre>

<p>The closure passed to <code>map</code> captures the field <code>factor</code> in the instance of <code>RDDApp</code>. However, the JVM must serialize the whole object, and a <code>NotSerializableException</code> will result when it attempts to serialize <code>log</code>.</p>

<p>Here is the work around; assign <code>factor</code> to a local field:</p>

<pre><code>class RDDApp {
  val factor = 3.14159
  val log = new Log(...)

  def multiply(rdd: RDD[Int]) = {
    val factor2 = factor
    rdd.map(x =&gt; x * factor2).reduce(...)
  }
}
</code></pre>

<p>Now, only <code>factor2</code> must be serialized.</p>

</div><div><h2>Going Forward from Here</h2>

<p>This template is not a complete Apache Spark tutorial. To learn more, see the following:</p>

<ul>
<li>The Apache Spark <a href="http://spark.apache.org/">website</a>.</li>
<li>The Apache Spark <a href="http://spark.apache.org/tree/develop/tutorial">tutorial</a> distributed with the <a href="http://spark.apache.org">Apache Spark</a> distribution. See also the examples in the distribution and be sure to study the <a href="http://spark.apache.org/docs/1.0.0/api.html">Scaladoc</a> pages for key types such as <code>RDD</code> and <code>SchemaRDD</code>.</li>
<li><a href="http://spark-summit.org/2013">Talks from Spark Summit 2013</a>.</li>
<li><a href="http://aws.amazon.com/articles/4926593393724923">Running Spark in EC2</a>.</li>
<li><a href="http://mesosphere.io/learn/run-spark-on-mesos/">Running Spark on Mesos</a>.</li>
</ul>


<p><strong>Experience Reports:</strong></p>

<ul>
<li><a href="http://www.slideshare.net/krishflix/seattle-spark-meetup-spark-at-twitter">Spark at Twitter</a></li>
</ul>


<p><strong>Other Spark Based Libraries:</strong></p>

<ul>
<li><a href="https://github.com/snowplow/spark-example-project">Snowplow's Spark Example Project</a>.</li>
<li><a href="https://github.com/freeman-lab/thunder">Thunder - Large-scale neural data analysis with Spark</a>.</li>
</ul>


</div><div><h2>For more about Typesafe:</h2>

<ul>
<li>See <a href="http://typesafe.com/activator">Typesafe Activator</a> to find other Activator templates.</li>
<li>See <a href="http://typesafe.com">Typesafe</a> for more information about our products and services.</li>
</ul>
</div>
</body>
</html>